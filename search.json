[{"title":"Java设计模式:单例模式","url":"%2F2019%2F10%2F17%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F","content":"## 单例模式简介\n### 定义\n保证一个类仅有一个实例，并提供一个访问它的全局访问入口。（你是我的唯一～～）\n### 为什么要用单例模式呢？\n&emsp;&emsp;其实生活中很多地方可以反应单例模式：比如一个国家只有一个总统；你正常合法的老婆只能有一个，别人叫你老婆时必须只能是同一个人（排除违法搞多个）。\n\n&emsp;&emsp;在软件系统中，有一些对象其实我们只需要一个比如：线程池、缓存、注册表、日志对象、充当打印机、显卡等设备驱动程序的对象等。事实上，这一类对象也只能有一个实例，如果制造出多个实例就可能会导致一些问题的产生，比如：程序的行为异常、资源使用过量、或者不一致性的结果等。\n\n&emsp;&emsp;一个简单场景就是：我们的应用程序有一些配置文件，我们希望只在系统启动的时候读取这些配置文件，并将这些配置保存在内存中，以后在程序中使用这些配置文件信息的时候不必再重新读取。这时候就需要使用单例模式。\n\n&emsp;&emsp;一般在下面两种场景下会考虑使用单例模式：\n1. 产生某对象会消耗过多的资源，为避免频繁地创建与销毁对象对资源的浪费。如：\n> 对数据库的操作、访问 IO、线程池（threadpool）、网络请求等。\n2. 某种类型的对象应该有且只有一个。如果制造出多个这样的实例会使程序异常。如：\n> 一个系统只能有：一个窗口管理器或文件系统，计时工具或 ID（序号）生成器，缓存（cache），处理偏好设置和注册表（registry）的对象，日志对象。\n\n&emsp;&emsp;简单来说使用单例模式可以带来下面几个好处：\n1. 对于频繁使用的对象，可以节省创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；\n2. 由于new操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。\n\n## 实现方式\n&emsp;&emsp;单例模式，按加载时机可以分为：饿汉方式和懒汉方式；按实现的方式，有：双重检查加锁，内部类方式和枚举方式等等。它们有的效率很高，有的节省内存，有的实现得简单漂亮，还有的存在严重缺陷，大部分使用的时候都有限制条件。下面我们来分析下各种写法的区别，辨别哪些是不可行的，哪些是推荐的，最后为大家筛选出几个值得我们适时应用到项目中的实现方式。\n\n### 饿汉模式\n&emsp;&emsp;所谓饿汉模式就是指全局的单例实例在类装载时构建。举个生活例子：妈妈早上起来为我们做饭吃，饭快做好的时候，一般都会叫我们起床吃饭，这是日常情况。如果饭还没有好的时候，我们就自己起来了（这时候妈妈还没有叫我们起床），这种情况在单例模式中称之为饿汉式，也就是说妈妈还没有叫我们起床，我们自己就起来的，就是外部还没有调用自己，自己的实例就已经创建好了。\n\n<details>\n```java\npublic class HungryPresident {\n\n    private static final HungryPresident INSTANCE = new HungryPresident();\n\n    // 私有化构造方法\n    private HungryPresident(){\n\n    }\n\n    public static HungryPresident getInstance() {\n        System.out.println(\"getInstance\");\n        return INSTANCE;\n    }\n}\n```\n**优缺点：**\n1. 简单实用，比较推荐。\n2. 类加载到内存后，只实例化一个实例，JVM保证线程安全，不用同步，运行效率高。\n3. 实例不管后续有没有使用，类加载完就完成实例化，外部一直没有调用该实例，那么这部分的系统资源的消耗是没有意义的。但话说如果这个类不用的话，你也没必要加载呀。\n> 代码测试验证：\n> ![](Java设计模式-单例模式/markdown-img-paste-20191021154529932.png)\n\n### 懒汉模式\n&emsp;&emsp;所谓的懒汉模式，就是一开始并不实例化对象，等到需要使用的时候才实例化。还是上面的例子，如果饭做好了，妈妈叫我们起床之后，我们才慢吞吞的起床，这种情况在单例模式中称之为懒汉式（饭都做好了，妈妈叫你起床之后，自己才起的，能不懒汉吗？就是外部对该类的方法发出调用之后，该实例才建立的）。\n<details>\n```java\npublic class LazyLoadPresident {\n\n    private static LazyLoadPresident INSTANCE;\n\n    private LazyLoadPresident() {\n\n    }\n\n    public static LazyLoadPresident getInstance() {\n\n        if (INSTANCE == null) {\n            System.out.println(\"getInstance\");\n            INSTANCE = new LazyLoadPresident();\n        }\n\n        return INSTANCE;\n    }\n}\n```\n**优缺点：**\n1. 实例在被使用的时候才被创建，可以节省系统资源，体现了延迟加载的思想。\n2. 多线程下，实例不能保证只有一个，线程不安全。\n> 代码测试验证：\n> ![](Java设计模式-单例模式/markdown-img-paste-20191021153411447.png)\n\n###\n","tags":["设计模式"],"categories":["设计模式"]},{"title":"Java设计模式剖析","url":"%2F2019%2F10%2F11%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%89%96%E6%9E%90%2F","content":"&emsp;&emsp;一直想写介绍设计模式的文章，让读者可以很快看完，而且一看就懂，看懂就会用，同时不会将各个模式搞混。当然这个需要有一定的编程经验才能做到。自己虽然不够nb，但也积累了一些经验，是时候写点东西了，也算是自我的总结。所以文中可能也存在一些纰漏，欢迎大家留言指正。\n\n&emsp;&emsp;设计模式（Design pattern）是一套应该被反复使用的代码设计经验的总结。使用设计模式是为了可复用代码、让代码更易理解、保证代码的可靠性。\n\n&emsp;&emsp;我知道大家（包括我在内）在写代码的时候可能不会那么刻意的去使用一些设计模式，但是它绝对是值得你去思考并使用的一套理论。项目中合理的运用设计模式可以完美的解决很多问题，并使你走向优秀代码的道路。\n\n&emsp;&emsp;我接下来的几篇文章会以理论与实践相结合的方式来进行总结，希望广大程序爱好者和我一起，学好设计模式，做一个优秀的软件工程师！\n\n## 设计模式六大原则\n学习设计模式之前最好先了解一下设计模式的设计原则：\n1. 开闭原则（open close principle）\n  开放即指对扩展开放，对修改关闭。简而言之，就是扩展功能的时候应该尽量的不修改原有的代码。\n2. 里氏代换原则（liskov substitution principle）\n  可以理解为派生类与基类的替换关系，是对\"开-闭\"原则的补充。通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。\n3. 依赖倒转原则（dependence inverse principle）\n  这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。目的是通过要面向接口的编程来降低类间的耦合性。符合高内聚低耦合原则。\n4. 接口隔离原则（Interface Segregation Principle）\n  使用多个隔离的接口，比使用单个接口要好，核心就是控制类的粒度大小、将对象解耦、提高其内聚性。\n5. 迪米特法则，又称最少知道原则（Demeter Principle）\n  一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。降低类之间的耦合度，提高了模块的相对独立性。\n6. 合成复用原则（Composite Reuse Principle）\n  尽量使用合成/聚合的方式，而不是使用继承。\n\n## 设计模式类型\n&emsp;&emsp;根据设计模式的参考书[Design Patterns - Elements of Reusable Object-Oriented Software](DesignPatterns.pdf)（中文译名：设计模式 - 可复用的面向对象软件元素，由GOF四人帮合著） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。\n### 创建型模式\n隐藏创建对象的创建逻辑，提供创建对象的接口，而非使用new关键字进行创建。\n* [单例模式（Singleton Pattern）](http://localhost:4000/2019/10/17/Java设计模式-单例模式/)\n* 工厂模式（Factory Pattern）\n* 抽象工厂模式（Abstract Factory Pattern）\n* 建造者模式（Builder Pattern）\n* 原型模式（Prototype Pattern）\n\n### 结构型模式\n这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。\n* 适配器模式（Adapter Pattern）\n* 桥接模式（Bridge Pattern）\n* 过滤器模式（Filter、Criteria Pattern）\n* 组合模式（Composite Pattern）\n* 装饰器模式（Decorator Pattern）\n* 外观模式（Facade Pattern）\n* 享元模式（Flyweight Pattern）\n* 代理模式（Proxy Pattern）\n\n### 行为型模式\n这些设计模式特别关注对象之间的通信。\n* 责任链模式（Chain of Responsibility Pattern）\n* 命令模式（Command Pattern）\n* 解释器模式（Interpreter Pattern）\n* 迭代器模式（Iterator Pattern）\n* 中介者模式（Mediator Pattern）\n* 备忘录模式（Memento Pattern）\n* 观察者模式（Observer Pattern）\n* 状态模式（State Pattern）\n* 空对象模式（Null Object Pattern）\n* 策略模式（Strategy Pattern）\n* 模板模式（Template Pattern）\n* 访问者模式（Visitor Pattern）\n\n设计模式之间的关系可以用下图整体描述：\n![](Java设计模式剖析/markdown-img-paste-2019101121061240.png)\n\n&emsp;&emsp;该文主要介绍一些基本概念和理论知识，后续文章会结合代码的形式详细介绍每种设计模式使用方式，如果你着急关注实际的使用，也可以跳转某一种设计模式单独了解，不必要按顺序阅读。\n","tags":["设计模式"],"categories":["设计模式"]},{"title":"conda使用技巧总结","url":"%2F2019%2F10%2F10%2Fconda%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%2F","content":"## 创建环境\n创建一个名为py35的环境，指定Python版本是3.5（不用管是3.5.x，conda会为我们自动寻找3.５.x中的最新版本）\n```python\nconda create --name py35 python=3.5\n```\n\n## 激活环境\n激活py35环境\n```python\nsource activate py35\n```\n\n## 返回主环境\n```python\nsource deactivate py35\n```\n\n## 删除环境\n删除一个已有的环境\n```python\nconda remove --name py35 --all\n```\n\n## 查看系统中的所有环境\n```python\nconda info -e\n```\n\n## 安装库\n```python\nconda install numpy\n```\n\n## 查看已经安装的库\n```python\nconda list\n```\n\n## 搜索package的信息\n```python\nconda search numpy\n```\n\n## 安装package到指定的环境\n如果不用-n指定环境名称，则被安装在当前活跃环境，也可以通过-c指定通过某个channel安装\n```python\nconda install -n py35 numpy\n```\n\n## 更新package\n```python\nconda update -n py35 numpy\n```\n\n## 删除package\n```python\nconda remove -n py35 numpy\n```\n\n## 设置国内镜像，加速conda\n在User主目录下生成.condarc文件，删掉channels下面的 -defaults一行,使其不再访问默认channel\n```python\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/\n\nconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/\n\nconda config --set show_channel_urls yes\n```\n","tags":["python"],"categories":["python"]},{"title":"mysql创建用户与授权","url":"%2F2019%2F10%2F09%2Fmysql%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E4%B8%8E%E6%8E%88%E6%9D%83%2F","content":"## 创建用户\n```sql\nCREATE USER 'username'@'host' IDENTIFIED BY 'password';\n```\n> 说明:\n> username：你将创建的用户名\n> host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符`%`\n> password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器\n> 例子：\n```sql\nCREATE USER 'pig'@'localhost' IDENTIFIED BY '123456';\nCREATE USER 'pig'@'%' IDENTIFIED BY '123456';\nCREATE USER 'pig'@'%' IDENTIFIED BY '';\nCREATE USER 'pig'@'%';\n```\n\n## 用户授权\n```sql\nGRANT privileges ON databasename.tablename TO 'username'@'host'\n```\n> 说明：\n> privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL\n> databasename：数据库名\n> tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用`*`表示，如`*.*`\n> 例子：\n```sql\nGRANT SELECT, INSERT ON test.user TO 'pig'@'%';\nGRANT ALL ON *.* TO 'pig'@'%';\nGRANT ALL ON test.* TO 'pig'@'%';\n```\n> **注意：**\n> 用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:\n```sql\nGRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION;\n```\n\n## 设置或更改用户密码\n```sql\nSET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword');\n```\n> 如果是当前登陆用户用:\n```sql\nSET PASSWORD = PASSWORD(\"newpassword\");\n```\n> 例子：\n```sql\nSET PASSWORD FOR 'pig'@'%' = PASSWORD(\"123456\");\nSET PASSWORD = PASSWORD(\"123456\");\n```\n\n## 撤销用户权限\n```sql\nREVOKE privilege ON databasename.tablename FROM 'username'@'host';\n```\n>具体信息可以用命令查看:\n```sql\nSHOW GRANTS FOR 'username'@'host';\n```\n\n## 删除用户\n```sql\nDROP USER 'username'@'host';\n```\n\n> 友情链接：https://www.cnblogs.com/sos-blue/p/6852945.html\n","tags":["mysql"],"categories":["mysql"]},{"title":"docker安装mysql搭建主从","url":"%2F2019%2F10%2F08%2Fdocker%E5%AE%89%E8%A3%85mysql%E6%90%AD%E5%BB%BA%E4%B8%BB%E4%BB%8E%2F","content":"## 查看镜像\ndocker search mysql:5.7\n## 拉取镜像\ndocker pull mysql:5.7\n## 运行mysql容器\n### 建立配置文件\n![](docker安装mysql搭建主从/markdown-img-paste-20191007232046365.png)\n#### master配置文件\nvim master/conf/my.cnf\n```\n[mysqld]\nserver_id = 1\nlog-bin= mysql-bin\nread-only=0\nreplicate-ignore-db=mysql\nreplicate-ignore-db=sys\nreplicate-ignore-db=information_schema\nreplicate-ignore-db=performance_schema\n```\n#### slave配置文件\nvim slave/conf/my.cnf\n```\n[mysqld]\nserver_id = 2\nlog-bin= mysql-bin\nlog_slave_updates=1\nread-only=1\nreplicate-ignore-db=mysql\nreplicate-ignore-db=sys\nreplicate-ignore-db=information_schema\nreplicate-ignore-db=performance_schema\n```\n> 注：从库还需要添加一个参数：log-slave-updates，log-slave-updates参数默认是关闭的状态，如果不手动设置，那么bin-log只会记录直接在主库上执行的SQL语句，由replication机制的SQL线程读取relay-log而执行的SQL语句并不会记录到bin-log，那么就无法实现从库binlog的实时同步。\n\n### 运行mysql-master\ndocker run --name mastermysql \\\n-p 3307:3306 \\\n-e MYSQL_ROOT_PASSWORD=123456 \\\n-v ~/opt/docker/mysql/master/data:/var/lib/mysql \\\n-v ~/opt/docker/mysql/master/conf/my.cnf:/etc/mysql/my.cnf \\\n-d mysql:5.7\n\n### 运行mysql-salve\ndocker run --name slavemysql \\\n-p 3308:3306 \\\n-e MYSQL_ROOT_PASSWORD=123456 \\\n-v ~/opt/docker/mysql/slave/data:/var/lib/mysql \\\n-v ~/opt/docker/mysql/slave/conf/my.cnf:/etc/mysql/my.cnf \\\n-d mysql:5.7\n\n## 查看docker镜像运行情况\ndocker ps\n![](docker安装mysql搭建主从/markdown-img-paste-20190926115002849.png)\n## 进入master容器\ndocker exec -it mastermysql bash\n## 进入mysql\nroot@a77371ae40bd:/# mysql -uroot -p123456\n## 查看master状态\nmysql> show master status;\n![](docker安装mysql搭建主从/markdown-img-paste-20190926115058346.png)\n\n## 创建binlog用户，授权\n### 创建binlog用户密码为binlog\nCREATE USER 'binlog'@'%' IDENTIFIED BY 'binlog';\n### 授权binlog用户拥有binlog库所有表的所有权限\nGRANT ALL ON binlog.* TO 'binlog'@'%';\n### 授予用户 binlog REPLICATION SLAVE 权限和 REPLICATION CLIENT 权限，用于在主从库之间同步数据。\nGRANT REPLICATION SLAVE, REPLICATION CLIENT ON \\*.\\* TO 'binlog'@'%';\n## 进入salve容器\ndocker exec -it slavemysql bash\n## 在Slave中进入mysql，执行:\n```\nCHANGE MASTER TO master_host = '172.17.0.2',\nmaster_user = 'binlog',\nmaster_password = 'binlog',\nmaster_port = 3306,\nmaster_log_file = 'mysql-bin.000003',\nmaster_log_pos = 154,\nmaster_connect_retry = 30;\n```\n\n**注：**\n>master_host ：Master 的地址，指的是容器的独立ip, 可以通过下面命令查询：\n\n>{%raw%} docker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称 | 容器id {%endraw%}\n\n>![](docker安装mysql搭建主从/markdown-img-paste-20190926115222899.png)\n\n>master_port：Master 的端口号，指的是容器的端口号\n\n>master_user：用于数据同步的用户\n\n>master_password：用于同步的用户的密码\n\n>master_log_file：指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值（主库记录的值）\n\n>master_log_pos：从哪个 Position 开始读，即上文中提到的 Position 字段的值（主库的pos值）\n\n>master_connect_retry：如果连接失败，重试的时间间隔，单位是秒，默认是 60 秒\n\n## 查询主从同步状态:\nshow slave status \\G;\n\n![](docker安装mysql搭建主从/markdown-img-paste-20190926115401342.png)\n\n## 开启主从复制过程\nstart slave;\n\n再次查询主从同步状态 show slave status \\G;\n![](docker安装mysql搭建主从/markdown-img-paste-20190926115534116.png)\n\n## 在master库新建binlog库 mlsql_binlog表进行同步测试：\n<details>\n```sql\ncreate database binlog;\n\nuse binlog;\n\nCREATE TABLE `mlsql_binlog` (\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n  `log` varchar(200) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) CHARSET=utf8;\n\ninsert into `mlsql_binlog` (`id`, `log`) values(1, 'hello');\n```\n> 友情链接：https://learnku.com/articles/30439\n","tags":["虚拟化"],"categories":["docker"]},{"title":"docker常用操作及技巧","url":"%2F2019%2F10%2F07%2Fdocker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%8A%E6%8A%80%E5%B7%A7%2F","content":"## Dockerfile命令\n> 官网介绍：https://docs.docker.com/engine/reference/builder/\n\n1. FROM\n\n   `FROM <image>:<tag>`\n\n    用于设置基础镜像，一般是Dockerfile的第一句。如果没有指定tag，则默认tag是latest。\n2. MAINTAINER\n\n   `MAINTAINER <name>`\n\n   用来指定维护者的姓名和联系方式。\n3. RUN\n\n   `RUN <command> 或 RUN [\"executable\",\"param1\",\"param2\"]`\n\n   每条 RUN 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。\n4. ADD\n\n   `ADD <src> <dest>`\n\n   将文件复制到文件：是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件 url，是容器中的绝对路径。\n\n5. COPY\n\n   `COPY <src> <dest>`\n\n   复制本地主机的（为Dockerfile所在目录的相对路径）到容器中的,与ADD指令差不多\n\n6. ENTRYPOINT\n\n   ```bash\n   ENTRYPOINT [\"executable\",\"param1\",\"param2\"] ：推荐使用的exec形式\n   ENTRYPOINT command param1 param2 ：shell 形式\n   ```\n\n   配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。一个 Dockerfile 中只能有一个 ENTRYPOINT，如果有多个，则最后一个生效。\n\n7. CMD\n   ```bash\n   CMD [\"executable\",\"param1\",\"param2\"] 使用exec执行，推荐方式；\n   CMD command param1 param2 在/bin/sh 中执行，提供给需要交互的应用；\n   CMD [\"param1\",\"param2\"]提供给ENTRYPOINT 的默认参数；\n   ```\n\n   指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。\n\n8. WORKDIR\n\n   `WORKDIR /path/to/workdir`\n\n   为后续的 RUN、CMD、ENTRYPOINT 指令配置工作目录。可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如：\n   WORKDIR /a\n   WORKDIR b\n   WORKDIR c\n   RUN pwd\n   则最终路径为 /a/b/c 。\n\n9. EXPOSE\n\n   `EXPOSE <port> [<port>...]`\n\n   告诉 Docker 服务端容器暴露的端口号，供互联系统使用。例如：EXPOSE 8080 3000，开放 8080 和 3000 端口。\n\n10. ENV\n\n    `ENV <key> <value>`\n    指定一个环境变量，会被后续 RUN 指令使用，并在容器运行时保持。\n\n11. VOLUME\n\n    `VOLUME [\"/data\"]`\n\n    创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。\n\n12. USER\n\n    `USER <UID/Username>`\n\n    为容器内指定 CMD RUN ENTRYPOINT 命令运行时的用户名或UID。\n\n## Docker常用命令\n> 官网介绍：https://docs.docker.com/engine/reference/commandline/docker/\n\n### 镜像相关\n1. 查看本地仓库的镜像：`docker images`\n2. 拉取远程仓库镜像：`docker pull REPOSITORY:TAG`\n3. 将本地镜像推送到远程仓库：`docker push REPOSITORY:TAG`\n> 一般需要三步：\n> A. 先将已有镜像打标签:`docker tag IMAGE_ID REPOSITORY:TAG` 需要tag为远程的仓库地址\n> B. 登录远程仓库：`docker login –username=USERNAME REPOSITORY_REGOIN`\n> C. 推送镜像到远程仓库：`docker push REPOSITORY:TAG`\n4. 使用Dockerfile构建镜像: `docker build -t REPOSITORY:TAG .`\n> .点表示当前目录，默认会找当前目录下的Dockerfile进行构建，也可以通过`-f`指定Dockerfile：`docker build -f /path/Dockerfile -t REPOSITORY:TAG .`\n5. 删除镜像：`docker rmi IMAGE_ID/ REPOSITORY:TAG`\n> 强制删除：`docker rmi -f IMAGE_ID`\n6. 删除untagged images：`docker rmi $(docker images | grep \"^<none>\" | awk \"{print $3}\")`\n7. 删除全部image：`docker rmi $(docker images -q)`\n8. 删除所有不使用的镜像：`docker image prune --force --all` 或 `docker image prune -f -a`\n\n### 容器相关\n1. 查看正在运行的容器：`docker ps`\n2. 列出所有容器ID：`docker ps -aq`\n3. 查看正在运行容器的日志：`docker logs -f CONTAINER_ID`\n4. 列出所有容器：`docker container list`\n5. 停止容器：`docker stop CONTAINER_ID`\n> 停止所有的container：`docker stop $(docker ps -a -q) `\n6. 删除容器：`docker rm CONTAINER_ID`\n> 删除所有container：`docker rm $(docker ps -a -q)`\n7. 从容器到宿主机复制：`docker cp CONTAINER:SRC_PATH DEST_PATH`\n8. 从宿主机到容器复制：`docker cp SRC_PATH CONTAINER:DEST_PATH`\n9. 删除所有停止的容器：`docker container prune`\n10. 停止/启动/杀死/重启一个容器：`docker stop/start/kill/restart CONTAINER_ID/CONTAINER_NAME`\n11. 进入容器：`docker exec -it CONTAINER_ID /bin/bash`\n> docker exec ：在运行的容器中执行命令\n> -d :分离模式: 在后台运行\n> -i :即使没有附加也保持STDIN（标准输入） 打开,以交互运行容器，通常与 -t 同时使用；\n> -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；\n12. 运行容器：`docker run [OPTIONS] IMAGE [COMMAND] [ARG...]`\n> OPTIONS说明：\n>\t-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；\n>\t-d: 后台运行容器，并返回容器ID；\n>\t-i: 以交互模式运行容器，通常与 -t 同时使用；\n>\t-P: 随机端口映射，容器内部端口随机映射到主机的高端口\n>\t-p: 指定端口映射，格式为：主机(宿主)端口:容器端口\n>\t-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；\n>\t--name=\"nginx-lb\": 为容器指定一个名称；\n>\t--dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；\n>\t--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；\n>\t-h \"mars\": 指定容器的hostname；\n>\t-e username=\"ritchie\": 设置环境变量；\n>\t--env-file=[]: 从指定文件读入环境变量；\n>\t--cpuset=\"0-2\" or --cpuset=\"0,1,2\": 绑定容器到指定CPU运行；\n>\t-m :设置容器使用内存最大值；\n>\t--net=\"bridge\": 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；\n>\t--link=[]: 添加链接到另一个容器；\n>\t--expose=[]: 开放一个端口或一组端口；\n>\t--volume , -v: 绑定一个卷\n","tags":["虚拟化"],"categories":["docker"]},{"title":"Hello World","url":"%2F2019%2F09%2F27%2Fhello-world%2F","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]