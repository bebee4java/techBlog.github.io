[{"title":"docker常用操作及技巧","url":"/2019/10/08/docker常用操作及技巧/","content":"## Dockerfile命令\n> 官网介绍：https://docs.docker.com/engine/reference/builder/\n\n1. FROM\n\n   `FROM <image>:<tag>`\n\n    用于设置基础镜像，一般是Dockerfile的第一句。如果没有指定tag，则默认tag是latest。\n2. MAINTAINER\n\n   `MAINTAINER <name>`\n\n   用来指定维护者的姓名和联系方式。\n3. RUN\n\n   `RUN <command> 或 RUN [\"executable\",\"param1\",\"param2\"]`\n\n   每条 RUN 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。\n4. ADD\n\n   `ADD <src> <dest>`\n\n   将文件复制到文件：是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件 url，是容器中的绝对路径。\n\n5. COPY\n\n   `COPY <src> <dest>`\n\n   复制本地主机的（为Dockerfile所在目录的相对路径）到容器中的,与ADD指令差不多\n\n6. ENTRYPOINT\n\n   ```bash\n   ENTRYPOINT [\"executable\",\"param1\",\"param2\"] ：推荐使用的exec形式\n   ENTRYPOINT command param1 param2 ：shell 形式\n   ```\n\n   配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。一个 Dockerfile 中只能有一个 ENTRYPOINT，如果有多个，则最后一个生效。\n\n7. CMD\n   ```bash\n   CMD [\"executable\",\"param1\",\"param2\"] 使用exec执行，推荐方式；\n   CMD command param1 param2 在/bin/sh 中执行，提供给需要交互的应用；\n   CMD [\"param1\",\"param2\"]提供给ENTRYPOINT 的默认参数；\n   ```\n\n   指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。\n\n8. WORKDIR\n\n   `WORKDIR /path/to/workdir`\n\n   为后续的 RUN、CMD、ENTRYPOINT 指令配置工作目录。可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如：\n   WORKDIR /a\n   WORKDIR b\n   WORKDIR c\n   RUN pwd\n   则最终路径为 /a/b/c 。\n\n9. EXPOSE\n\n   `EXPOSE <port> [<port>...]`\n\n   告诉 Docker 服务端容器暴露的端口号，供互联系统使用。例如：EXPOSE 8080 3000，开放 8080 和 3000 端口。\n\n10. ENV\n\n    `ENV <key> <value>`\n    指定一个环境变量，会被后续 RUN 指令使用，并在容器运行时保持。\n\n11. VOLUME\n\n    `VOLUME [\"/data\"]`\n\n    创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。\n\n12. USER\n\n    `USER <UID/Username>`\n\n    为容器内指定 CMD RUN ENTRYPOINT 命令运行时的用户名或UID。\n\n## Docker常用命令\n> 官网介绍：https://docs.docker.com/engine/reference/commandline/docker/\n\n### 镜像相关\n1. 查看本地仓库的镜像：`docker images`\n2. 拉取远程仓库镜像：`docker pull REPOSITORY:TAG`\n3. 将本地镜像推送到远程仓库：`docker push REPOSITORY:TAG`\n> 一般需要三步：\n> A. 先将已有镜像打标签:`docker tag IMAGE_ID REPOSITORY:TAG` 需要tag为远程的仓库地址\n> B. 登录远程仓库：`docker login –username=USERNAME REPOSITORY_REGOIN`\n> C. 推送镜像到远程仓库：`docker push REPOSITORY:TAG`\n4. 使用Dockerfile构建镜像: `docker build -t REPOSITORY:TAG .`\n> .点表示当前目录，默认会找当前目录下的Dockerfile进行构建，也可以通过`-f`指定Dockerfile：`docker build -f /path/Dockerfile -t REPOSITORY:TAG .`\n5. 删除镜像：`docker rmi IMAGE_ID/ REPOSITORY:TAG`\n> 强制删除：`docker rmi -f IMAGE_ID`\n6. 删除untagged images：`docker rmi $(docker images | grep \"^<none>\" | awk \"{print $3}\")`\n7. 删除全部image：`docker rmi $(docker images -q)`\n8. 删除所有不使用的镜像：`docker image prune --force --all` 或 `docker image prune -f -a`\n\n### 容器相关\n1. 查看正在运行的容器：`docker ps`\n2. 列出所有容器ID：`docker ps -aq`\n3. 查看正在运行容器的日志：`docker logs -f CONTAINER_ID`\n4. 列出所有容器：`docker container list`\n5. 停止容器：`docker stop CONTAINER_ID`\n> 停止所有的container：`docker stop $(docker ps -a -q) `\n6. 删除容器：`docker rm CONTAINER_ID`\n> 删除所有container：`docker rm $(docker ps -a -q)`\n7. 从容器到宿主机复制：`docker cp CONTAINER:SRC_PATH DEST_PATH`\n8. 从宿主机到容器复制：`docker cp SRC_PATH CONTAINER:DEST_PATH`\n9. 删除所有停止的容器：`docker container prune`\n10. 停止/启动/杀死/重启一个容器：`docker stop/start/kill/restart CONTAINER_ID/CONTAINER_NAME`\n11. 进入容器：`docker exec -it CONTAINER_ID /bin/bash`\n> docker exec ：在运行的容器中执行命令\n> -d :分离模式: 在后台运行\n> -i :即使没有附加也保持STDIN（标准输入） 打开,以交互运行容器，通常与 -t 同时使用；\n> -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；\n12. 运行容器：`docker run [OPTIONS] IMAGE [COMMAND] [ARG...]`\n> OPTIONS说明：\n>\t-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；\n>\t-d: 后台运行容器，并返回容器ID；\n>\t-i: 以交互模式运行容器，通常与 -t 同时使用；\n>\t-P: 随机端口映射，容器内部端口随机映射到主机的高端口\n>\t-p: 指定端口映射，格式为：主机(宿主)端口:容器端口\n>\t-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；\n>\t--name=\"nginx-lb\": 为容器指定一个名称；\n>\t--dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；\n>\t--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；\n>\t-h \"mars\": 指定容器的hostname；\n>\t-e username=\"ritchie\": 设置环境变量；\n>\t--env-file=[]: 从指定文件读入环境变量；\n>\t--cpuset=\"0-2\" or --cpuset=\"0,1,2\": 绑定容器到指定CPU运行；\n>\t-m :设置容器使用内存最大值；\n>\t--net=\"bridge\": 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；\n>\t--link=[]: 添加链接到另一个容器；\n>\t--expose=[]: 开放一个端口或一组端口；\n>\t--volume , -v: 绑定一个卷\n","tags":["docker","虚拟化"],"categories":["docker"]},{"title":"docker安装mysql搭建主从","url":"/2019/10/07/docker安装mysql搭建主从/","content":"## 查看镜像\ndocker search mysql:5.7\n## 拉取镜像\ndocker pull mysql:5.7\n## 运行mysql容器\n### 建立配置文件\n![](docker安装mysql搭建主从/markdown-img-paste-20191007232046365.png)\n#### master配置文件\nvim master/conf/my.cnf\n```\n[mysqld]\nserver_id = 1\nlog-bin= mysql-bin\nread-only=0\nreplicate-ignore-db=mysql\nreplicate-ignore-db=sys\nreplicate-ignore-db=information_schema\nreplicate-ignore-db=performance_schema\n```\n#### slave配置文件\nvim slave/conf/my.cnf\n```\n[mysqld]\nserver_id = 2\nlog-bin= mysql-bin\nlog_slave_updates=1\nread-only=1\nreplicate-ignore-db=mysql\nreplicate-ignore-db=sys\nreplicate-ignore-db=information_schema\nreplicate-ignore-db=performance_schema\n```\n> 注：从库还需要添加一个参数：log-slave-updates，log-slave-updates参数默认是关闭的状态，如果不手动设置，那么bin-log只会记录直接在主库上执行的SQL语句，由replication机制的SQL线程读取relay-log而执行的SQL语句并不会记录到bin-log，那么就无法实现从库binlog的实时同步。\n\n### 运行mysql-master\ndocker run --name mastermysql \\\n-p 3307:3306 \\\n-e MYSQL_ROOT_PASSWORD=123456 \\\n-v ~/opt/docker/mysql/master/data:/var/lib/mysql \\\n-v ~/opt/docker/mysql/master/conf/my.cnf:/etc/mysql/my.cnf \\\n-d mysql:5.7\n\n### 运行mysql-salve\ndocker run --name slavemysql \\\n-p 3308:3306 \\\n-e MYSQL_ROOT_PASSWORD=123456 \\\n-v ~/opt/docker/mysql/slave/data:/var/lib/mysql \\\n-v ~/opt/docker/mysql/slave/conf/my.cnf:/etc/mysql/my.cnf \\\n-d mysql:5.7\n\n## 查看docker镜像运行情况\ndocker ps\n![](docker安装mysql搭建主从/markdown-img-paste-20190926115002849.png)\n## 进入master容器\ndocker exec -it mastermysql bash\n## 进入mysql\nroot@a77371ae40bd:/# mysql -uroot -p123456\n## 查看master状态\nmysql> show master status;\n![](docker安装mysql搭建主从/markdown-img-paste-20190926115058346.png)\n\n## 创建binlog用户，授权\n### 创建binlog用户密码为binlog\nCREATE USER 'binlog'@'%' IDENTIFIED BY 'binlog';\n### 授权binlog用户拥有binlog库所有表的所有权限\nGRANT ALL ON binlog.* TO 'binlog'@'%';\n### 授予用户 binlog REPLICATION SLAVE 权限和 REPLICATION CLIENT 权限，用于在主从库之间同步数据。\nGRANT REPLICATION SLAVE, REPLICATION CLIENT ON \\*.\\* TO 'binlog'@'%';\n## 进入salve容器\ndocker exec -it slavemysql bash\n## 在Slave中进入mysql，执行:\n```\nCHANGE MASTER TO master_host = '172.17.0.2',\nmaster_user = 'binlog',\nmaster_password = 'binlog',\nmaster_port = 3306,\nmaster_log_file = 'mysql-bin.000003',\nmaster_log_pos = 154,\nmaster_connect_retry = 30;\n```\n\n**注：**\n>master_host ：Master 的地址，指的是容器的独立ip, 可以通过下面命令查询：\n\n>{%raw%} docker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称 | 容器id {%endraw%}\n\n>![](docker安装mysql搭建主从/markdown-img-paste-20190926115222899.png)\n\n>master_port：Master 的端口号，指的是容器的端口号\n\n>master_user：用于数据同步的用户\n\n>master_password：用于同步的用户的密码\n\n>master_log_file：指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值（主库记录的值）\n\n>master_log_pos：从哪个 Position 开始读，即上文中提到的 Position 字段的值（主库的pos值）\n\n>master_connect_retry：如果连接失败，重试的时间间隔，单位是秒，默认是 60 秒\n\n## 查询主从同步状态:\nshow slave status \\G;\n\n![](docker安装mysql搭建主从/markdown-img-paste-20190926115401342.png)\n\n## 开启主从复制过程\nstart slave;\n\n再次查询主从同步状态 show slave status \\G;\n![](docker安装mysql搭建主从/markdown-img-paste-20190926115534116.png)\n\n## 在master库新建binlog库 mlsql_binlog表进行同步测试：\n```sql\ncreate database binlog;\n\nuse binlog;\n\nCREATE TABLE `mlsql_binlog` (\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n  `log` varchar(200) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) CHARSET=utf8;\n\ninsert into `mlsql_binlog` (`id`, `log`) values(1, 'hello');\n```\n> 友情链接：https://learnku.com/articles/30439\n","tags":["docker","虚拟化"],"categories":["docker"]},{"title":"Hello World","url":"/2019/09/27/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]