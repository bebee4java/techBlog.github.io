<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[docker常用操作及技巧]]></title>
    <url>%2F2019%2F10%2F08%2Fdocker%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%8F%8A%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[Dockerfile命令 官网介绍：https://docs.docker.com/engine/reference/builder/ FROM FROM &lt;image&gt;:&lt;tag&gt; 用于设置基础镜像，一般是Dockerfile的第一句。如果没有指定tag，则默认tag是latest。 MAINTAINER MAINTAINER &lt;name&gt; 用来指定维护者的姓名和联系方式。 RUN RUN &lt;command&gt; 或 RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 每条 RUN 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。 ADD ADD &lt;src&gt; &lt;dest&gt; 将文件复制到文件：是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件 url，是容器中的绝对路径。 COPY COPY &lt;src&gt; &lt;dest&gt; 复制本地主机的（为Dockerfile所在目录的相对路径）到容器中的,与ADD指令差不多 ENTRYPOINT 12ENTRYPOINT ["executable","param1","param2"] ：推荐使用的exec形式ENTRYPOINT command param1 param2 ：shell 形式 配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。一个 Dockerfile 中只能有一个 ENTRYPOINT，如果有多个，则最后一个生效。 CMD 123CMD ["executable","param1","param2"] 使用exec执行，推荐方式；CMD command param1 param2 在/bin/sh 中执行，提供给需要交互的应用；CMD ["param1","param2"]提供给ENTRYPOINT 的默认参数； 指定启动容器时执行的命令，每个 Dockerfile 只能有一条 CMD 命令。如果指定了多条命令，只有最后一条会被执行。如果用户启动容器时候指定了运行的命令，则会覆盖掉 CMD 指定的命令。 WORKDIR WORKDIR /path/to/workdir 为后续的 RUN、CMD、ENTRYPOINT 指令配置工作目录。可以使用多个 WORKDIR 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如：WORKDIR /aWORKDIR bWORKDIR cRUN pwd则最终路径为 /a/b/c 。 EXPOSE EXPOSE &lt;port&gt; [&lt;port&gt;...] 告诉 Docker 服务端容器暴露的端口号，供互联系统使用。例如：EXPOSE 8080 3000，开放 8080 和 3000 端口。 ENV ENV &lt;key&gt; &lt;value&gt;指定一个环境变量，会被后续 RUN 指令使用，并在容器运行时保持。 VOLUME VOLUME [&quot;/data&quot;] 创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。 USER USER &lt;UID/Username&gt; 为容器内指定 CMD RUN ENTRYPOINT 命令运行时的用户名或UID。 Docker常用命令 官网介绍：https://docs.docker.com/engine/reference/commandline/docker/ 镜像相关 查看本地仓库的镜像：docker images 拉取远程仓库镜像：docker pull REPOSITORY:TAG 将本地镜像推送到远程仓库：docker push REPOSITORY:TAG 一般需要三步：A. 先将已有镜像打标签:docker tag IMAGE_ID REPOSITORY:TAG 需要tag为远程的仓库地址B. 登录远程仓库：docker login –username=USERNAME REPOSITORY_REGOINC. 推送镜像到远程仓库：docker push REPOSITORY:TAG 使用Dockerfile构建镜像: docker build -t REPOSITORY:TAG . .点表示当前目录，默认会找当前目录下的Dockerfile进行构建，也可以通过-f指定Dockerfile：docker build -f /path/Dockerfile -t REPOSITORY:TAG . 删除镜像：docker rmi IMAGE_ID/ REPOSITORY:TAG 强制删除：docker rmi -f IMAGE_ID 删除untagged images：docker rmi $(docker images | grep &quot;^&lt;none&gt;&quot; | awk &quot;{print $3}&quot;) 删除全部image：docker rmi $(docker images -q) 删除所有不使用的镜像：docker image prune --force --all 或 docker image prune -f -a 容器相关 查看正在运行的容器：docker ps 列出所有容器ID：docker ps -aq 查看正在运行容器的日志：docker logs -f CONTAINER_ID 列出所有容器：docker container list 停止容器：docker stop CONTAINER_ID 停止所有的container：docker stop $(docker ps -a -q) 删除容器：docker rm CONTAINER_ID 删除所有container：docker rm $(docker ps -a -q) 从容器到宿主机复制：docker cp CONTAINER:SRC_PATH DEST_PATH 从宿主机到容器复制：docker cp SRC_PATH CONTAINER:DEST_PATH 删除所有停止的容器：docker container prune 停止/启动/杀死/重启一个容器：docker stop/start/kill/restart CONTAINER_ID/CONTAINER_NAME 进入容器：docker exec -it CONTAINER_ID /bin/bash docker exec ：在运行的容器中执行命令-d :分离模式: 在后台运行-i :即使没有附加也保持STDIN（标准输入） 打开,以交互运行容器，通常与 -t 同时使用；-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker安装mysql搭建主从]]></title>
    <url>%2F2019%2F10%2F07%2Fdocker%E5%AE%89%E8%A3%85mysql%E6%90%AD%E5%BB%BA%E4%B8%BB%E4%BB%8E%2F</url>
    <content type="text"><![CDATA[查看镜像docker search mysql:5.7 拉取镜像docker pull mysql:5.7 运行mysql容器建立配置文件 master配置文件vim master/conf/my.cnf12345678[mysqld]server_id = 1log-bin= mysql-binread-only=0replicate-ignore-db=mysqlreplicate-ignore-db=sysreplicate-ignore-db=information_schemareplicate-ignore-db=performance_schema slave配置文件vim slave/conf/my.cnf123456789[mysqld]server_id = 2log-bin= mysql-binlog_slave_updates=1read-only=1replicate-ignore-db=mysqlreplicate-ignore-db=sysreplicate-ignore-db=information_schemareplicate-ignore-db=performance_schema 注：从库还需要添加一个参数：log-slave-updates，log-slave-updates参数默认是关闭的状态，如果不手动设置，那么bin-log只会记录直接在主库上执行的SQL语句，由replication机制的SQL线程读取relay-log而执行的SQL语句并不会记录到bin-log，那么就无法实现从库binlog的实时同步。 运行mysql-masterdocker run —name mastermysql \-p 3307:3306 \-e MYSQL_ROOT_PASSWORD=123456 \-v ~/opt/docker/mysql/master/data:/var/lib/mysql \-v ~/opt/docker/mysql/master/conf/my.cnf:/etc/mysql/my.cnf \-d mysql:5.7 运行mysql-salvedocker run —name slavemysql \-p 3308:3306 \-e MYSQL_ROOT_PASSWORD=123456 \-v ~/opt/docker/mysql/slave/data:/var/lib/mysql \-v ~/opt/docker/mysql/slave/conf/my.cnf:/etc/mysql/my.cnf \-d mysql:5.7 查看docker镜像运行情况docker ps 进入master容器docker exec -it mastermysql bash 进入mysqlroot@a77371ae40bd:/# mysql -uroot -p123456 查看master状态mysql&gt; show master status; 创建binlog用户，授权创建binlog用户密码为binlogCREATE USER ‘binlog’@’%’ IDENTIFIED BY ‘binlog’; 授权binlog用户拥有binlog库所有表的所有权限GRANT ALL ON binlog.* TO ‘binlog’@’%’; 授予用户 binlog REPLICATION SLAVE 权限和 REPLICATION CLIENT 权限，用于在主从库之间同步数据。GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO ‘binlog’@’%’; 进入salve容器docker exec -it slavemysql bash 在Slave中进入mysql，执行:1234567CHANGE MASTER TO master_host = &apos;172.17.0.2&apos;,master_user = &apos;binlog&apos;,master_password = &apos;binlog&apos;,master_port = 3306,master_log_file = &apos;mysql-bin.000003&apos;,master_log_pos = 154,master_connect_retry = 30; 注： master_host ：Master 的地址，指的是容器的独立ip, 可以通过下面命令查询： docker inspect --format='{{.NetworkSettings.IPAddress}}' 容器名称 | 容器id master_port：Master 的端口号，指的是容器的端口号 master_user：用于数据同步的用户 master_password：用于同步的用户的密码 master_log_file：指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值（主库记录的值） master_log_pos：从哪个 Position 开始读，即上文中提到的 Position 字段的值（主库的pos值） master_connect_retry：如果连接失败，重试的时间间隔，单位是秒，默认是 60 秒 查询主从同步状态:show slave status \G; 开启主从复制过程start slave; 再次查询主从同步状态 show slave status \G; 在master库新建binlog库 mlsql_binlog表进行同步测试：1234567891011create database binlog;use binlog;CREATE TABLE `mlsql_binlog` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `log` varchar(200) DEFAULT NULL, PRIMARY KEY (`id`)) CHARSET=utf8;insert into `mlsql_binlog` (`id`, `log`) values(1, 'hello'); 友情链接：https://learnku.com/articles/30439]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>虚拟化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
